/* Generated By:JJTree&JavaCC: Do not edit this line. Compiler.java */
package parser;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import javax.swing.JOptionPane;
import java.util.*;

@SuppressWarnings("all")
public class Compiler/*@bgen(jjtree)*/implements CompilerTreeConstants, CompilerConstants {/*@bgen(jjtree)*/
  protected JJTCompilerState jjtree = new JJTCompilerState();
        public static int count=0; //å››å…ƒå¼æ ‡å?
        public static int ncount=0; //ä¸´æ—¶å˜é‡ä¸‹æ ‡
        public static int con;
        public static int j=0;
        public static FileOutputStream foutStream ;
        public static PrintStream print_Stream;
        public static ArrayList<MyNode> mylist=new ArrayList<MyNode>();//ç»“ç‚¹é›†åˆ
        public static ArrayList<QTInfo> myQTInfo=new ArrayList<QTInfo>(); //å››å…ƒå¼?
        public static QTTable table=new QTTable(myQTInfo);//å››å…ƒå¼é“¾è¡¨ï¼Œç”¨æ¥å­˜å‚¨ç»“æœ
        public static NodeList   myNodeList=new NodeList(mylist);//å°è£…ç»“ç‚¹é›†åˆï¼Œå¯¹ç»“ç‚¹è¿›è¡Œå¤„ç†


//å››å…ƒå¼è¡¨  
    public static void QTInfoTable()
  {
        try{
           FileOutputStream out=new FileOutputStream("Systable.txt");
           PrintStream QTInfoprint=new PrintStream(out);
           //tempï¼šéå†å››å…ƒå¼åˆ—è¡¨å¹¶æ‰“å?
           for(QTInfo temp:myQTInfo)
           {
                  QTInfoprint.print(temp);
           }
            QTInfoprint.close();
           out.close();
          }
          catch(IOException e)
          {
                e.printStackTrace();
          }

  }


//è¯æ³•åˆ†æï¼Œè¾“å‡?å•è¯è‡ªèº«å€¼ï¼Œå•è¯ç§åˆ«>äºŒå…ƒå¼?
  public static void WordAnalysis()
  {
        try{
        SimpleCharStream jj_input_stream=new SimpleCharStream(new FileInputStream(GUI.show.sf));
                CompilerTokenManager tokenManage=new CompilerTokenManager(jj_input_stream);
                FileOutputStream out=new FileOutputStream("WordAnalysis.txt");
                PrintStream wordprint=new PrintStream(out);
                ArrayList<Word> wordlist=new ArrayList<Word>();
                while(true)
                {
                        //è¯»å–ä¸‹ä¸€å•è¯
                        Token t=tokenManage.getNextToken();
                        if(t.kind==0)//æºæ–‡ä»¶ç»“æŸï¼Œè·³å‡ºå¾ªç¯
                        {
                                break;
                        }
                        else
                        {//å°†å•è¯ä¿¡æ¯å°è£…åœ¨wordé‡Œå­˜å‚?
                        Word w = new Word();
                        w.setKind(t.kind);
                        w.setName(t.image);
                    wordlist.add(w);
                        }
                }
                //éå†ï¼Œæ‰“å°äºŒå…ƒå¼
                for(Word temp:wordlist)
                {
                        wordprint.print(temp);
                }
                wordprint.close();
                out.close();
        }
        catch(Exception e)
        {
                e.printStackTrace();
        }

  }

//å¼?§‹
  final public SimpleNode Start() throws ParseException {
                      /*@bgen(jjtree) Start */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VOID:
        Procedure();
        jj_consume_token(0);
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
         {if (true) return jjtn000;}
        break;
      case 0:
        jj_consume_token(0);
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
              {if (true) return jjtn000;}
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//<ç¨‹åºã€‰â†’ void main() {ã€ˆè¯­å¥å—ã€‰}
  final public void Procedure() throws ParseException {
                  /*@bgen(jjtree) Procedure */
  SimpleNode jjtn000 = new SimpleNode(JJTPROCEDURE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(VOID);
      jj_consume_token(MAIN);
      jj_consume_token(LC);
      jj_consume_token(RC);
      SentenceBlock();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//ã€ˆè¯­å¥å—ã€‰â†’{ã€ˆè¯­å¥ä¸²ã€‰}
  final public void SentenceBlock() throws ParseException {
                      /*@bgen(jjtree) SentenceBlock */
  SimpleNode jjtn000 = new SimpleNode(JJTSENTENCEBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LB);
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IF:
        case WHILE:
        case DO:
        case FOR:
        case SWITCH:
        case FLOAT:
        case LONG:
        case SHORT:
        case INT:
        case CHAR:
        case DOUBLE:
        case SELFPLUS:
        case SELFMINUS:
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_1;
        }
        Statement();
      }
      jj_consume_token(RB);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//ã€ˆè¯­å¥ä¸²ã€‰â†’ã€ˆèµ‹å€¼è¯­å¥ã?|ã€ˆæ¡ä»¶è¯­å¥ã?|ã€ˆå¾ªç¯è¯­å¥ã?ç­?....
  final public void Statement() throws ParseException {
                  /*@bgen(jjtree) Statement */
  SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FLOAT:
      case LONG:
      case SHORT:
      case INT:
      case CHAR:
      case DOUBLE:
        declaration();
        break;
      case SELFPLUS:
      case SELFMINUS:
      case IDENTIFIER:
        assignment();
        break;
      case IF:
        If();
        break;
      case SWITCH:
        Switch();
        break;
      case WHILE:
        While();
        break;
      case DO:
        do_while();
        break;
      case FOR:
        For();
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//å£°æ˜è¯­å¥ï¼ˆå²³å† æ¡¥ï¼?
  final public void declaration() throws ParseException {
 /*@bgen(jjtree) declaration */
  SimpleNode jjtn000 = new SimpleNode(JJTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String type;//å˜é‡ç±»å‹
  MyNode tempnode=null;//åœ¨ç¬¦å·è¡¨å»ºç«‹tempnodeèŠ‚ç‚¹ï¼Œå­˜å‚¨å˜é‡å…¨éƒ¨ä¿¡æ?
  Token node;//å•è¯
  String name;//å˜é‡åç§°
  int D=0;
    try {
      type = Type();
      node = jj_consume_token(IDENTIFIER);
                name=node.image;
                //æ£?Ÿ¥æ ‡ç¤ºç¬¦æ˜¯å¦å·²å®šä¹‰ï¼Œè‹¥æ˜¯åˆ™æŠ¥é”™ï¼Œé?å‡ºç¨‹åº?
                if(myNodeList!=null)
                {
                        if(myNodeList.isExientence(name))
                        {
                          String s = "number "+node.beginLine+"  variable \u005c""+name+"\u005c" already exist";
                JOptionPane.showMessageDialog(null,s,"error", JOptionPane.ERROR_MESSAGE);
                        }
                }
                tempnode=new MyNode(name,type);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LM:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_2;
        }
        jj_consume_token(LM);
                D++;
                tempnode.D  = D;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CONSTANT:
          node = jj_consume_token(CONSTANT);
                if(D==1)//è‹¥ä¸ºä¸?»´æ•°ç»„ï¼Œè®¾ç½®è¡Œé•¿åº¦
                {
                        int row=Integer.parseInt(node.image);
                        tempnode.row = row;
                        tempnode.a=new int[row];
                        tempnode.rflag=1;
                }
                else if(D==2)//è‹¥ä¸ºäºŒç»´æ•°ç»„ï¼Œè®¾ç½®åˆ—é•¿åº¦
                {
                        int col=Integer.parseInt(node.image);
                        tempnode.col = col;
                        tempnode.a=null;
                        tempnode.b=new int[tempnode.row][col];
                        tempnode.cflag=1;
                }
          break;
        default:
          jj_la1[4] = jj_gen;
          ;
        }
        jj_consume_token(RM);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGNMENT:
        Assign(tempnode);
        break;
      default:
        jj_la1[5] = jj_gen;
        ;
      }
                myNodeList.addNode(tempnode);
                D=0;
                node=null;
                tempnode=null;
                name=null;
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_3;
        }
        jj_consume_token(DOT);
        node = jj_consume_token(IDENTIFIER);
                name=node.image;
                if(myNodeList!=null)
                {
                        if(myNodeList.isExientence(name))
                        {
                          String s = "number "+node.beginLine+"  variable \u005c""+name+"\u005c" already exist";
                           JOptionPane.showMessageDialog(null,s,"error", JOptionPane.ERROR_MESSAGE);

                        }
                }
                tempnode=new MyNode(name,type);
        label_4:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LM:
            ;
            break;
          default:
            jj_la1[7] = jj_gen;
            break label_4;
          }
          jj_consume_token(LM);
                D++;
                tempnode.D = D;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CONSTANT:
            node = jj_consume_token(CONSTANT);
            if(D==1)
                {
                        int row=Integer.parseInt(node.image);
                        tempnode.row = row;
                        tempnode.a=new int[row];
                        tempnode.rflag=1;
                }
                else if(D==2)
                {
                        int col=Integer.parseInt(node.image);
                        tempnode.col = col;
                        tempnode.a=null;
                        tempnode.b=new int[tempnode.row][col];
                        tempnode.cflag=1;
                }
            break;
          default:
            jj_la1[8] = jj_gen;
            ;
          }
          jj_consume_token(RM);
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASSIGNMENT:
          Assign(tempnode);
          break;
        default:
          jj_la1[9] = jj_gen;
          ;
        }
                myNodeList.addNode(tempnode);
                D=0;
                tempnode=null;
                node=null;
                name=null;
      }
      jj_consume_token(SEMICOLON);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//èµ‹å?è¯­å¥ï¼ˆæ¨å¸…ï¼‰
  final public void Assign(MyNode tempnode) throws ParseException {
 /*@bgen(jjtree) Assign */
        SimpleNode jjtn000 = new SimpleNode(JJTASSIGN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Record temp;//ä¸´æ—¶å˜é‡
        String st;//ä¸‹æ ‡ä¸´æ—¶æ ‡è®°
        int value; //å˜é‡çš„å?
        int i=0;
        int j=0;
        String lon;
        int row,col;
        int nr=0;
    try {
      jj_consume_token(ASSIGNMENT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LC:
      case IDENTIFIER:
      case CONSTANT:
        temp = Factor();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                value=Integer.parseInt(temp.getValue());
                tempnode.result=value;
                count++;
                QTTable.addQTInfo(new QTInfo(count,"=",temp.getName(),"-",tempnode.name));
        break;
      case LB:
        jj_consume_token(LB);
ArrayList<Integer> list=new ArrayList<Integer>();//ç”¨ä¸€ä¸?/ArrayList<Integer>è¿ç»­æ¥æ”¶åé¢å¤§æ‹¬å·å†…çš„å?ï¼Œå¾…æ‰«æå®Œæ¯•åï¼Œå†?/ä¿®æ”¹tempnodeå¹¶ç”Ÿæˆç›¸åº”çš„å››å…ƒå¼ã?

        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LC:
        case IDENTIFIER:
        case CONSTANT:
          temp = Factor();
            if(tempnode.rflag==1&&nr>=tempnode.row)
            {
                        String s  = "number "+" Index out of array!! "+tempnode.name;//è¡Œè¶Šç•ŒæŠ¥é”™ã?
                        JOptionPane.showMessageDialog(null,s,"error", JOptionPane.ERROR_MESSAGE);
            }
            nr++;//å¦‚æœä¸æŠ¥é”™ï¼Œåˆ™è¡Œ++
                value=Integer.parseInt(temp.getValue());
                list.add(value);
          label_5:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DOT:
              ;
              break;
            default:
              jj_la1[10] = jj_gen;
              break label_5;
            }
            jj_consume_token(DOT);
            temp = Factor();
                if(tempnode.rflag==1&&nr>=tempnode.row)
            {
                        String s = "number "+" Index out of array!! "+tempnode.name;//è¶Šç•ŒæŠ¥é”™
                        JOptionPane.showMessageDialog(null,s,"error", JOptionPane.ERROR_MESSAGE);
            }
            nr++;
                value=Integer.parseInt(temp.getValue());
                list.add(value);
          }
                if(tempnode.rflag==0)//ä¿®æ”¹å®šä¹‰æ ‡è®°
                {
                   tempnode.rflag=1;
                   tempnode.row = nr;
                   tempnode.a=new int[nr];
                }
                st="T"+(ncount);
                ncount++;
                count++;
                QTTable.addQTInfo(new QTInfo(count,"=",0+"","-",st));
                Iterator it=list.iterator();//è¿­ä»£å–listé‡Œçš„æ•°æ”¾è¿?/tempnode.aæ•°ç»„é‡Œã?
                while(it.hasNext())
                {
                        tempnode.a[i]=(Integer)it.next();
                count++;
                    QTTable.addQTInfo(new QTInfo(count,"[]=",tempnode.a[i]+"","-",tempnode.name+"["+st+"]"));//å­˜æ•°
                    i++;
                    lon=st;
                    if(it.hasNext())
                    {
                    st="T"+(ncount);
                    ncount++;
                    count++;
                    QTTable.addQTInfo(new QTInfo(count,"+",lon,4+"",st));
                    }
                }
          break;
        case LB:
          Array(tempnode,j++,list);
          label_6:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DOT:
              ;
              break;
            default:
              jj_la1[11] = jj_gen;
              break label_6;
            }
            jj_consume_token(DOT);
            Array(tempnode,j++,list);
          }
                        if(tempnode.rflag==0)
                {
                        tempnode.rflag=1;
                        tempnode.row = j;
                        tempnode.b=new int [tempnode.row][tempnode.col];
                }
                i=0;j=0;int co=0;
                st="T"+(ncount);
                ncount++;
                count++;
                QTTable.addQTInfo(new QTInfo(count,"=",0+"","-",st));//å­˜æ•°//å¼?§‹
                Iterator ait=list.iterator();
                while(ait.hasNext())
                {
                        tempnode.b[i][j]=(Integer)ait.next();
                        count++;
                    QTTable.addQTInfo(new QTInfo(count,"[]=",tempnode.b[i][j]+"","-",tempnode.name+"["+st+"]"));
                    lon=st;
                    if(ait.hasNext()){
                    st="T"+(ncount);
                    ncount++;
                    count++;
                    QTTable.addQTInfo(new QTInfo(count,"+",lon,4+"",st));
                    }
                        j++;
                        co++;
                        if(co%tempnode.col==0)//è¯»å®Œä¸?¡Œåï¼Œç»§ç»­è¯»ä¸‹ä¸?¡Œ
                        {
                                i++;
                                j=0;
                        }
                }
          break;
        default:
          jj_la1[12] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RB);
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//äºŒç»´æ•°ç»„èµ‹å?ï¼ˆå®æ—ï¼‰
  final public void Array(MyNode tempnode,int row,ArrayList<Integer> list) throws ParseException {
 /*@bgen(jjtree) Array */
        SimpleNode jjtn000 = new SimpleNode(JJTARRAY);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Record temp;
        int value;
        int i=0;
        int nr=0;
        int cl;
    try {
      jj_consume_token(LB);
                if(tempnode.rflag==1&&row>=tempnode.row)//è¡Œè¶Šç•ŒæŠ¥é”?
                {
                        String s = "number "+" Row Index out of array!! "+tempnode.name;
                        JOptionPane.showMessageDialog(null,s,"error", JOptionPane.ERROR_MESSAGE);

                }
      temp = Factor();
            if(tempnode.cflag==1&&nr>=tempnode.col)
            {
                        String s = "number "+" Col Index out of array!! "+tempnode.name;
                        JOptionPane.showMessageDialog(null,s,"error", JOptionPane.ERROR_MESSAGE);

            }
            nr++;
                value=Integer.parseInt(temp.getValue());
                list.add(value);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT:
          ;
          break;
        default:
          jj_la1[14] = jj_gen;
          break label_7;
        }
        jj_consume_token(DOT);
        temp = Factor();
            if(tempnode.cflag==1&&nr>=tempnode.col)//åˆ—è¶Šç•ŒæŠ¥é”?
            {
                        String s = "number "+" Col Index out of array!! "+tempnode.name;
                        JOptionPane.showMessageDialog(null,s,"error", JOptionPane.ERROR_MESSAGE);
            }
            nr++;
                value=Integer.parseInt(temp.getValue());
                list.add(value);
      }
                if(tempnode.cflag==0)
                {
                   tempnode.cflag=1;
                   tempnode.col = nr;
                }
      jj_consume_token(RB);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//è¯»å–å€¼ï¼ˆå®æ—ï¼?
//Recordï¼šå°è£…nameã€valueä¿¡æ¯ï¼Œåœ¨è¯­ä¹‰åˆ†æè¿‡ç¨‹ä¸­ä½œä¸ºä¸´æ—¶å˜é‡ä½¿ç”?
//Factorï¼ˆï¼‰â€”â?>å¸¸æ•° | å­—ç¬¦ä¸²ï¼ˆ â€œ[â€? å¸¸æ•°  â€]â€?ï¼?
//Factorè¡¨ç¤ºæŠŠä¸€ä¸ªæ•´æ•°ï¼Œå˜é‡ï¼Œå¸¸é‡ï¼Œè¡¨è¾¾å¼æˆ–æ•°ç»„è½¬æ¢æˆä¸ºä¸?¸ªRecordç±»ï¼Œ
//è¯¥ç±»å­˜åœ¨ä¸¤ä¸ªå˜é‡nameå’Œvalueã€‚nameå­˜å‚¨åå­—ï¼Œvalueå­˜å?
  final public Record Factor() throws ParseException {
 /*@bgen(jjtree) Factor */
        SimpleNode jjtn000 = new SimpleNode(JJTFACTOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String name,value="";
        Token node;
        int D=0;
        MyNode tempnode;
        int row=-1,col=-1;
        int rl,cl;
        String temp="",lon="";
        Record r;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONSTANT:
        node = jj_consume_token(CONSTANT);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                name=node.image;
                value=node.image;
                {if (true) return new Record(name,value);}
        break;
      case LC:
        jj_consume_token(LC);
        r = Expression();
        jj_consume_token(RC);
                                jjtree.closeNodeScope(jjtn000, true);
                                jjtc000 = false;
                               //è¡¨è¾¾å¼?
                {if (true) return r;}
        break;
      case IDENTIFIER:
        node = jj_consume_token(IDENTIFIER);
                name=node.image;
                tempnode=myNodeList.getNode(name);//ä»ç¬¦å·è¡¨é‡Œæ‰¾åˆ°nameå˜é‡ï¼Œå¹¶æŠŠnameçš„å…¨éƒ¨ä¿¡æ¯èµ‹ç»™tempnodeå˜é‡

        label_8:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LM:
            ;
            break;
          default:
            jj_la1[15] = jj_gen;
            break label_8;
          }
          jj_consume_token(LM);
          node = jj_consume_token(CONSTANT);
                D++;
                if(D==1)
                {
                    row=Integer.parseInt(node.image);//æŠŠæ•´å‹å¯¹è±¡Integerè½¬æ¢æˆåŸºæœ¬æ•°æ®ç±»å‹intã€?
                }
                else if(D==2)
                {
                        col=Integer.parseInt(node.image);
                }
          jj_consume_token(RM);
        }
                if(D==1)
                {
                    if(!myNodeList.isExientence(name)||(myNodeList.getNode(name)).D!=1)
                   {
                        String s = "number "+node.beginLine+" Array "+name+" is undefined";// æ•°ç»„æ²¡æœ‰å®šä¹‰ï¼ŒæŠ¥é”?
                        JOptionPane.showMessageDialog(null,s,"error", JOptionPane.ERROR_MESSAGE);

                   }
                   if(row>=tempnode.row)
                   {
                           String s = "number "+node.beginLine+" Index out of array!! "+name;//è¶Šç•ŒæŠ¥é”™
                           JOptionPane.showMessageDialog(null,s,"error", JOptionPane.ERROR_MESSAGE);

                        }
//å››å…ƒå¼?
                   value=tempnode.a[row]+"";
                   temp="T"+(ncount);
                   ncount++;
                   count++;
                   QTTable.addQTInfo(new QTInfo(count,"*",row+"",4+"",temp));//è·å–æ•°ç»„çš„å…¥å£åœ°å?
                   lon=temp;
                        temp="T"+ncount;
                        ncount++;
                        count++;
                    QTTable.addQTInfo(new QTInfo(count,"=[]",name+"["+lon+"]","-",temp));//å˜å€å–æ•°
                }
                else if(D==2)
                {
                    if(!myNodeList.isExientence(name)||(myNodeList.getNode(name)).D!=2)
                   {

                        String s = "number "+node.beginLine+" Array "+name+" is undefined";
                        JOptionPane.showMessageDialog(null,s,"error", JOptionPane.ERROR_MESSAGE);

                   }
                    if(row>=tempnode.row)
                        {
                           String s = "number "+node.beginLine+" Row Index out of array!! "+name;
                           JOptionPane.showMessageDialog(null,s,"error", JOptionPane.ERROR_MESSAGE);

                        }
                        if(col>=tempnode.col)
                        {
                           String s = "number "+node.beginLine+" Col Index out of array!! "+name;
                           JOptionPane.showMessageDialog(null,s,"error", JOptionPane.ERROR_MESSAGE);

                        }
                        value=tempnode.b[row][col]+"";
                        cl=tempnode.col;//c1è¡¨ç¤ºäºŒç»´æ•°ç»„çš„åˆ—é•¿åº¦
                temp="T"+(ncount);//ä¸´æ—¶å˜é‡ä¸‹æ ‡ï¼Œåˆå§‹å?ä¸?
                    ncount++;
                    count++;//å››å…ƒå¼æ ‡å?
                    QTTable.addQTInfo(new QTInfo(count,"*",row+"",cl+"",temp));//è·å–æ•°ç»„çš„å…¥å£åœ°å?
                    lon=temp;//ä¸?¸ªæ ‡è®°
                    temp="T"+(ncount);
                    ncount++;
                    count++;
                    QTTable.addQTInfo(new QTInfo(count,"+",lon,col+"",temp));//æ›´æ–°tempæ ‡è®°
                    lon=temp;//ä¸?¸ªæ ‡è®°
                    temp="T"+(ncount);
                    ncount++;
                    count++;
                    QTTable.addQTInfo(new QTInfo(count,"*",lon,4+"",temp));//æ‰¾åˆ°ä½ç½®
                    lon=temp;
                        temp="T"+ncount;
                        ncount++;
                        count++;
                    QTTable.addQTInfo(new QTInfo(count,"=[]",name+"["+lon+"]","-",temp)); //å˜å€å–æ•°

                }
                else if(D==0)
                {
                         if(!myNodeList.isExientence(name)||(myNodeList.getNode(name)).D!=0)
                    {
                        String s = "number "+node.beginLine+" variable "+name+" is undefined";
                        JOptionPane.showMessageDialog(null,s,"error", JOptionPane.ERROR_MESSAGE);

                   }
                  value=tempnode.result+"";
                }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                if(tempnode.D==0)
                {//å¸¸æ•°
                        {if (true) return new Record(tempnode.name,value);}
                }
                else
                {//æ•°ç»„
                        {if (true) return new Record(temp,value);}  //è¿”å›æ•°ç»„çš„tempå’Œå?
                }
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

//èµ‹å?è¯­å¥ï¼ˆç‹é¹¤æ·³ï¼?
  final public void assignment() throws ParseException {
 /*@bgen(jjtree) assignment */
        SimpleNode jjtn000 = new SimpleNode(JJTASSIGNMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t;
        Token id;
        Token node;
        String idenfier; //è¢«èµ‹å€¼å¯¹è±?
        Record middle;
        String symbol;
        int result;
        MyNode tempnode=null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        id = jj_consume_token(IDENTIFIER);
                idenfier=id.image;
                if(!myNodeList.isExientence(idenfier)){
                                String s = "variable \u005c""+idenfier+"\u005c" doesn't exist."
                                +"\u005cnwrong number "+id.beginLine;
                                JOptionPane.showMessageDialog(null,s,"error", JOptionPane.ERROR_MESSAGE);

                        }
                tempnode=myNodeList.getNode(idenfier);//è·å–å¯¹è±¡çš„å¼•ç”?
                if(tempnode.type=="char"|tempnode.type=="short"){
                        String s = "variable type is not  right"
                                +"\u005cnwrong number "+id.beginLine;
                                JOptionPane.showMessageDialog(null,s,"error", JOptionPane.ERROR_MESSAGE);

                }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASSIGNMENT:
          jj_consume_token(ASSIGNMENT);
          middle = Expression();
                count++;
                QTTable.addQTInfo(new QTInfo(count,"=",middle.getName(),"_",idenfier));
                tempnode.result=Integer.parseInt(middle.getValue());
          break;
        case PLUS:
        case MINUS:
        case MULTIPLY:
        case DIVIDE:
        case REMAINDER:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PLUS:
            node = jj_consume_token(PLUS);
            break;
          case MINUS:
            node = jj_consume_token(MINUS);
            break;
          case MULTIPLY:
            node = jj_consume_token(MULTIPLY);
            break;
          case DIVIDE:
            node = jj_consume_token(DIVIDE);
            break;
          case REMAINDER:
            node = jj_consume_token(REMAINDER);
            break;
          default:
            jj_la1[17] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                symbol=node.image;
          jj_consume_token(ASSIGNMENT);
          middle = Expression();
                count++;
                QTTable.addQTInfo(new QTInfo(count,symbol,idenfier,middle.getName(),idenfier));
                if(symbol.equals("+")){
                        tempnode.result+=Integer.parseInt(middle.getValue());//æ›´æ–°æ•°å?
                }else if(symbol.equals("-")){
                        tempnode.result+=Integer.parseInt(middle.getValue());//æ›´æ–°æ•°å?
                }else if(symbol.equals("*")){
                        tempnode.result*=Integer.parseInt(middle.getValue());//æ›´æ–°æ•°å?
                }else{
                        tempnode.result/=Integer.parseInt(middle.getValue());//æ›´æ–°æ•°å?
                }
          break;
        case SELFPLUS:
          jj_consume_token(SELFPLUS);
                count++;
                QTTable.addQTInfo(new QTInfo(count,"+",idenfier,"1",idenfier));
                tempnode.result+=1;//æ›´æ–°æ•°å?

          break;
        case SELFMINUS:
          jj_consume_token(SELFMINUS);
                count++;
                tempnode.result-=1;//æ›´æ–°æ•°å?
                QTTable.addQTInfo(new QTInfo(count,"-",idenfier,"1",idenfier));
          break;
        default:
          jj_la1[18] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEMICOLON:
          jj_consume_token(SEMICOLON);
          break;
        case DOT:
          jj_consume_token(DOT);
          break;
        default:
          jj_la1[19] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case SELFPLUS:
        jj_consume_token(SELFPLUS);
        id = jj_consume_token(IDENTIFIER);
                idenfier=id.image;
                count++;
                QTTable.addQTInfo(new QTInfo(count,"+",idenfier,"1",idenfier));
        jj_consume_token(SEMICOLON);
        break;
      case SELFMINUS:
        jj_consume_token(SELFMINUS);
        id = jj_consume_token(IDENTIFIER);
                idenfier=id.image;
                count++;
                QTTable.addQTInfo(new QTInfo(count,"-",idenfier,"1",idenfier));
        jj_consume_token(SEMICOLON);
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//ã€ˆæ¡ä»¶è¯­å¥ã?â†?ifã€ˆæ¡ä»¶ã?ã€ˆè¯­å¥å—ã€‰ï¼ˆéƒé‡‘å¼ºï¼‰
  final public void If() throws ParseException {
           /*@bgen(jjtree) If */
   SimpleNode jjtn000 = new SimpleNode(JJTIF);
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);int j1, j2=0, j3;
    try {
      jj_consume_token(IF);
      jj_consume_token(LC);
      Condition();
      jj_consume_token(RC);
   count++;
   j1=count;
   QTTable.addQTInfo(new QTInfo(count,"J","_","_",String.valueOf(j1)+"#"));//ifå‡å‡ºå£ï¼Œtargetç”¨j1#ä»£æ›¿

      SentenceBlock();
   count++;
   QTTable.addQTInfo(new QTInfo(count,"J","_","_",String.valueOf(j2)+"#"));//æ‰?œ‰è¯­å¥æ‰§è¡Œå®Œæ¯•ä¹‹åï¼Œæ·»åŠ è·³è½¬è¯­å¥ï¼Œtargetç”¨J2#ä»£æ›¿
   QTTable.replaceFirst(String.valueOf(j1)+"#",String.valueOf(count+1)+"");
  //å°†æ•°å›å¡«åˆ°åˆšæ‰ifçš„å‡å‡ºå£ï¼Œå°†j1#ç”¨count+1æ›¿æ¢

      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ELSEIF:
          ;
          break;
        default:
          jj_la1[21] = jj_gen;
          break label_9;
        }
        jj_consume_token(ELSEIF);
        jj_consume_token(LC);
        Condition();
        jj_consume_token(RC);
   count++;
   j3=count;
   QTTable.addQTInfo(new QTInfo(count,"J","_","_",String.valueOf(j3)+"#"));//elseå‡å‡ºå?targetç”¨j3#ä»£æ›¿

        SentenceBlock();
   count++;
       QTTable.addQTInfo(new QTInfo(count,"J","_","_",String.valueOf(j2)+"#"));//elseé‡Œçš„æ‰?œ‰è¯­å¥æ‰§è¡Œå®Œæ¯•ä¹‹åï¼Œæ·»åŠ è·³è½¬å››å…ƒå¼ï¼Œtargetç”¨J2#ä»£æ›¿
   QTTable.replaceFirst(String.valueOf(j3)+"#",String.valueOf(count+1)+"");//å›å¡«åˆ°elseifçš„å‡å‡ºå£ï¼Œå°†j3#ç”¨count+1ä»£æ›¿

      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELSE:
        jj_consume_token(ELSE);
        SentenceBlock();
        break;
      default:
        jj_la1[22] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  QTTable.replaceAll(String.valueOf(j2)+"#",String.valueOf(count+1)+"");//å°†æ‰€æœ‰çš„æ— æ¡ä»¶è·³è½¬è¯­å¥å—çš„j2#æ›¿æ¢ä¸ºå½“å‰çš„count+1

    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

//switchæ¡ä»¶è¯­å¥ï¼ˆéƒé‡‘å¼ºï¼?
  final public void Switch() throws ParseException {
 /*@bgen(jjtree) Switch */
SimpleNode jjtn000 = new SimpleNode(JJTSWITCH);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token node;
int j1=0;
int j2;
int next;
Record idenfier;//æ ‡è¯†ç¬?
Record con;
    try {
      jj_consume_token(SWITCH);
         j2=-1;
      jj_consume_token(LC);
      idenfier = Expression();
      jj_consume_token(RC);
      jj_consume_token(LB);
      label_10:
      while (true) {
        jj_consume_token(CASE);
        QTTable.replaceFirst(String.valueOf(j1)+"#",String.valueOf(count+1));
        con = Expression();
        count++;
        next=count+1;
        QTTable.addQTInfo(new QTInfo(count,"J=",idenfier.getName(),con.getName(),String.valueOf(next+1)));
        count++;
        j1=count;
        QTTable.addQTInfo(new QTInfo(count,"J","_","_",String.valueOf(j1)+"#"));//å‡å‡ºå£ï¼Œtargetç”¨j1#æ ‡è®°

        jj_consume_token(COLON);
        SentenceBlock();
        count++;
        QTTable.addQTInfo(new QTInfo(count,"J","_","_",String.valueOf(j2)+"#"));//è·³è½¬ï¼Œtargetç”¨j2#æ ‡è®°

        jj_consume_token(BREAK);
        jj_consume_token(SEMICOLON);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CASE:
          ;
          break;
        default:
          jj_la1[23] = jj_gen;
          break label_10;
        }
      }
      jj_consume_token(DEFAULT1);
        QTTable.replaceFirst(String.valueOf(j1)+"#",String.valueOf(count+1));//å›å¡«ï¼Œå°†j1#ç”¨å½“å‰count+1æ›¿æ¢
        next=count+1;
      jj_consume_token(COLON);
      SentenceBlock();
      jj_consume_token(BREAK);
        count++;
        QTTable.addQTInfo(new QTInfo(count,"J","_","_",String.valueOf(count+1)));//ç»“æŸè¯­å¥

      jj_consume_token(SEMICOLON);
      jj_consume_token(RB);
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
        QTTable.replaceAll(String.valueOf(j2)+"#",String.valueOf(count+1)+"");//å›å¡«ï¼Œå°†æ‰?œ‰çš„j2#ç”¨å½“å‰çš„count+1æ›¿æ¢

    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

//do_whileè¯­å¥ï¼ˆç¨‹è™¹ç¿”ï¼?
  final public void do_while() throws ParseException {
 /*@bgen(jjtree) do_while */
        SimpleNode jjtn000 = new SimpleNode(JJTDO_WHILE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token node;
        int next;
        int dofirst;
    try {
      jj_consume_token(DO);
                //è®°ä½doçš„ç¬¬ä¸?¸ªè¯­å¥
                dofirst=count+1;
      SentenceBlock();
      jj_consume_token(WHILE);
      jj_consume_token(LC);
      While_Condition();
        //æ¡ä»¶æˆç«‹è·³è½¬åˆ°å¾ªç¯ä½“çš„ç¬¬ä¸?¡è¯­å¥
                QTTable.replaceAll("-2#",String.valueOf(dofirst));
      jj_consume_token(RC);
      jj_consume_token(SEMICOLON);
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
                next=count+1;
                //æ‰?œ‰æ¡ä»¶ä¸æˆç«‹è·³å‡ºå¾ªç¯ä½“å³ä¸‹ä¸?¡è¯­å¥
                QTTable.replaceAll("0#",String.valueOf(next));
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//whileè¯­å¥ï¼ˆç¨‹è™¹ç¿”ï¼?
  final public void While() throws ParseException {
 /*@bgen(jjtree) While */
  SimpleNode jjtn000 = new SimpleNode(JJTWHILE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token node;
  int j1;
  int j2;
  int next;
  int next1;
  int wh;
    try {
      jj_consume_token(WHILE);
      jj_consume_token(LC);
        next1=count+1;
      While_Condition();
      jj_consume_token(RC);
        wh=count+1;
        //è¿›å…¥å¾ªç¯ä½?
        QTTable.replaceAll("-2#",String.valueOf(wh));
        //å°†whileæ¡ä»¶ä¸æˆç«‹çš„åšä¸€ä¸ªæ ‡è®?
        QTTable.replaceAll("0#",String.valueOf(wh)+"&");
      SentenceBlock();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
        count++;
        next=count+1;
        QTTable.replaceAll(String.valueOf(wh)+"&",String.valueOf(next));
        //å¾ªç¯ç»“æŸè·³è½¬è¿”å›åˆ¤æ–­æ¡ä»¶æ˜¯å¦æˆç«‹
        QTTable.addQTInfo(new QTInfo(count,"J","_","_",String.valueOf(next1)));
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

//whileä¸­çš„æ¡ä»¶åˆ¤æ–­è¯­å¥ï¼ˆç‹é¹¤æ·³ï¼?
  final public void While_Condition() throws ParseException {
 /*@bgen(jjtree) While_Condition */
  SimpleNode jjtn000 = new SimpleNode(JJTWHILE_CONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token node;
  Record result;
  Record middle;
  int j=0;
  int j1;
  int j2;
  int j3=-2;
  String symbol;
    try {
      result = Expression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOWER:
        node = jj_consume_token(LOWER);
        break;
      case GREAT:
        node = jj_consume_token(GREAT);
        break;
      case GREATE:
        node = jj_consume_token(GREATE);
        break;
      case LOWERW:
        node = jj_consume_token(LOWERW);
        break;
      case EQUAL:
        node = jj_consume_token(EQUAL);
        break;
      case UNEQUAL:
        node = jj_consume_token(UNEQUAL);
        break;
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        symbol=node.image;
      middle = Expression();
        count++;
    con=count;
        QTTable.addQTInfo(new QTInfo(count,"j"+symbol,result.getName(),middle.getName(),String.valueOf(con)+"#"));
        count++;
        QTTable.addQTInfo(new QTInfo(count,"j","_","_",String.valueOf(j)+"#"));
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AND:
          ;
          break;
        default:
          jj_la1[25] = jj_gen;
          break label_11;
        }
        jj_consume_token(AND);
        //ç»§ç»­åˆ¤æ–­
        j1=count+1;
        QTTable.replaceFirst(String.valueOf(con)+"#",String.valueOf(j1));
        While_Condition();
      }
        //æ¡ä»¶æˆç«‹åšä¸€ä¸ªæ ‡è®?
        QTTable.replaceFirst(String.valueOf(con)+"#",String.valueOf(j3)+"#");
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OR:
          ;
          break;
        default:
          jj_la1[26] = jj_gen;
          break label_12;
        }
        jj_consume_token(OR);
        //andæ¡ä»¶éƒ½ä¸æˆç«‹çš„è¯è·³è½¬åˆ°or
        j2=count+1;
        QTTable.replaceAll(String.valueOf(j)+"#",String.valueOf(j2));
        While_Condition();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

//forå¾ªç¯è¯­å¥ï¼ˆæ¨å¸…ï¼‰
  final public void For() throws ParseException {
 /*@bgen(jjtree) For */
         SimpleNode jjtn000 = new SimpleNode(JJTFOR);
         boolean jjtc000 = true;
         jjtree.openNodeScope(jjtn000);int j1;
         int j2;
         Token node=null,node1=null;
    try {
      jj_consume_token(FOR);
      jj_consume_token(LC);
      assignment();
                 j1=count+1;
      While_Condition();
         //å†™ä¸¤æ¡å››å…ƒå¼
                j++;
                QTTable.replaceAll("-2#",j+"-2#");//çœŸå‡ºå£ï¼Œæ›¿æ¢æ‰?œ‰ï¼ŒæŠŠ-2#æ›¿æ¢ä¸?-2#
                QTTable.replaceAll("0#",j+"0#");//å‡å‡ºå£ï¼Œæ›¿æ¢æ‰?œ‰ï¼ŒæŠŠ0#æ›¿æ¢ä¸?0#
                j2=count+1;
      jj_consume_token(SEMICOLON);
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          node = jj_consume_token(IDENTIFIER);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SELFPLUS:
            node1 = jj_consume_token(SELFPLUS);
            break;
          case SELFMINUS:
            node1 = jj_consume_token(SELFMINUS);
            break;
          default:
            jj_la1[27] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        case DOT:
          jj_consume_token(DOT);
          break;
        default:
          jj_la1[28] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT:
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[29] = jj_gen;
          break label_13;
        }
      }
      jj_consume_token(RC);
      SentenceBlock();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         //å†™è¯­å¥å—è¯­å¥çš„å››å…ƒå¼	
        {//æ‰§è¡Œ++æˆ?-
                count++;//å¯¹å››å…ƒå¼åºå·çš„æ“ä½?
                if(node1.image=="++"){
                QTTable.addQTInfo(new QTInfo(count,"+",node.image,"1",node.image));
                }//æ·»åŠ ä¸?¡å››å…ƒå¼ï¼Œå‡½æ•°é‡Œçš„å‚æ•°æ˜¯ä¸€ä¸ªQTInfoå¯¹è±¡ï¼Œnewæ–°å»ºä¸?¡å››å…ƒå¼ï¼Œç±»é‡Œé¢ä¹Ÿæœ?ä¸ªå‚æ•°ï¼Œ
                          //countæ˜¯å››å…ƒå¼æ ‡å·ï¼?+çš„å››å…ƒå¼ç›¸å½“äºæ˜¯+1çš„é‚£ç§å››å…ƒå¼
                else{
                QTTable.addQTInfo(new QTInfo(count,"-",node.image,"1",node.image));
                }
                count++;//æ ‡å·+1
                QTTable.addQTInfo(new QTInfo(count,"j","_","_",String.valueOf(j1)));//æ— æ¡ä»¶è·³è½¬è¯­å?
        }
                QTTable.replaceAll(j+"-2#",String.valueOf(j2));//æ›¿æ¢j2çš„å?
                QTTable.replaceAll(j+"0#",String.valueOf(count+1));//æ›¿æ¢è¯­å¥ï¼?2#ä»£è¡¨çœŸå‡ºå£ï¼Œ0#ä»£è¡¨å‡å‡ºå?
                                                                   //æ›¿æ¢count+1çš„å?
                j--;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//ã€ˆæ¡ä»¶ã?â†’ï¼ˆã€ˆè¡¨è¾¾å¼ã€‰ã?å…³ç³»ç¬¦ã?ã€ˆè¡¨è¾¾å¼ã€‰ï¼‰ï¼ˆç¨‹è™¹ç¿”ï¼?
  final public int Condition() throws ParseException {
 /*@bgen(jjtree) Condition */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token node;
  int next;
  Record result;
  Record middle;
    try {
      //	Expression()(Relate() Expression())
        result = Expression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOWER:
        node = jj_consume_token(LOWER);
        middle = Expression();
        count++;
        next=count+1;
        QTTable.addQTInfo(new QTInfo(count,"j<",result.getName(),middle.getName(),String.valueOf(next+1)));
        break;
      case GREAT:
        node = jj_consume_token(GREAT);
        middle = Expression();
        count++;
        next=count+1;
        QTTable.addQTInfo(new QTInfo(count,"j>",result.getName(),middle.getName(),String.valueOf(next+1)));
        break;
      case GREATE:
        node = jj_consume_token(GREATE);
        middle = Expression();
        count++;
        next=count+1;
        QTTable.addQTInfo(new QTInfo(count,"j>=",result.getName(),middle.getName(),String.valueOf(next+1)));
        break;
      case LOWERW:
        node = jj_consume_token(LOWERW);
        middle = Expression();
        count++;
        next=count+1;
        QTTable.addQTInfo(new QTInfo(count,"j<=",result.getName(),middle.getName(),String.valueOf(next+1)));
        break;
      case EQUAL:
        node = jj_consume_token(EQUAL);
        middle = Expression();
        count++;
        next=count+1;
        QTTable.addQTInfo(new QTInfo(count,"j=",result.getName(),middle.getName(),String.valueOf(next+1)));
        break;
      case UNEQUAL:
        node = jj_consume_token(UNEQUAL);
        middle = Expression();
        count++;
        next=count+1;
        QTTable.addQTInfo(new QTInfo(count,"j!=",result.getName(),middle.getName(),String.valueOf(next+1)));
        break;
      default:
        jj_la1[30] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
        {if (true) return next;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//åŠ å‡è¿ç®—è¡¨è¾¾å¼ï¼ˆéƒé‡‘å¼ºï¼‰
  final public Record Expression() throws ParseException {
 /*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token node;
  Record rValue;//å­˜å‚¨å‰ä¸€ä¸ªTerm()ä¿¡æ¯
  Record middleR;//å­˜å‚¨åä¸€ä¸ªTerm()ä¿¡æ¯
  String result=null;//å‰ä¸€ä¸ªTerm()çš„å?
  String middle=null;//åä¸€ä¸ªTerm()çš„å?
  String middletemp=null;//åä¸€ä¸ªTerm()çš„åç§?
  String temp="";//å‰ä¸€ä¸ªTerm()çš„åç§?
  String preStr=null;
  String pretem="";//ç¬¬ä¸€ä¸ªä¸´æ—¶å˜é‡åç§?
  int perStep=0;
    try {
      rValue = Term();
        temp=rValue.getName();
        result=rValue.getValue();
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
        case MINUS:
          ;
          break;
        default:
          jj_la1[31] = jj_gen;
          break label_14;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          jj_consume_token(PLUS);
        if(preStr!=null){
                pretem="T"+(ncount-1);//å‰ä¸€ä¸ªä¸´æ—¶å˜é‡?
        }
          middleR = Term();
                 //è¯»å–åä¸€ä¸ªTerm()
        middletemp=middleR.getName();
        middle=middleR.getValue();
        count++;//å››å…ƒå¼ä¸‹æ ‡è‡ªå¢?
        temp="T"+(ncount);//ä¸´æ—¶å˜é‡
        //ä¸ºä¸‹ä¸?¸ªä¸´æ—¶å˜é‡åšå‡†å¤?
        ncount++;
        if(preStr==null){
                QTTable.addQTInfo(new QTInfo(count,"+",rValue.getName(),middletemp,temp));

        }else{
                //æŠŠå¼€å§‹å?å’Œä¸­é—´å?æ”¾åœ¨ä¸´æ—¶å˜é‡é‡?
                QTTable.addQTInfo(new QTInfo(count,"+",pretem,middletemp,temp));
        }
        //å­˜å‚¨è®¡ç®—ç»“æœçš„å?
        result=Integer.parseInt(result)+Integer.parseInt(middle)+"";
        preStr=temp;
          break;
        case MINUS:
          jj_consume_token(MINUS);
        if(preStr!=null){
                pretem="T"+(ncount-1);
        }
          middleR = Term();
        middletemp=middleR.getName();
        middle=middleR.getValue();
        count++;
        temp="T"+ncount;
        ncount++;
        if(preStr==null){
                //æŠŠå¼€å§‹å?å’Œä¸­é—´å?æ”¾åœ¨ä¸´æ—¶å˜é‡é‡?
                QTTable.addQTInfo(new QTInfo(count,"-",rValue.getName(),middletemp,temp));
        }else{
                //æŠŠå¼€å§‹å?å’Œä¸­é—´å?æ”¾åœ¨ä¸´æ—¶å˜é‡é‡?
                QTTable.addQTInfo(new QTInfo(count,"-",pretem,middletemp,temp));
        }
        result=Integer.parseInt(result)-Integer.parseInt(middle)+"";
        preStr=temp;
          break;
        default:
          jj_la1[32] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
        rValue=new Record(temp,result);
        {if (true) return rValue;}//æœ?è¿”å›è¡¨è¾¾å¼çš„å€¼å³å?

    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//ä¹˜é™¤è¿ç®—è¡¨è¾¾å¼ï¼ˆå®æ—ï¼?
  final public Record Term() throws ParseException {
 /*@bgen(jjtree) Term */
  SimpleNode jjtn000 = new SimpleNode(JJTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token node;
  Record rValue=null;//å­˜å‚¨å‰ä¸€ä¸ªTerm()ä¿¡æ¯
  Record MiddleR=null;//å­˜å‚¨åä¸€ä¸ªTerm()ä¿¡æ¯
  String result;//å‰ä¸€ä¸ªTerm()çš„å?
  String middle;//åä¸€ä¸ªTerm()çš„å?
  String middletemp;
  String middleName;
  String temp="";
  String symbol="";//è¿ç®—ç¬?
  String preStr=null;
  String pretem=null;
    try {
      rValue = Factor();
        temp=rValue.getName();
        result=rValue.getValue();
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MULTIPLY:
        case DIVIDE:
        case REMAINDER:
          ;
          break;
        default:
          jj_la1[33] = jj_gen;
          break label_15;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MULTIPLY:
          node = jj_consume_token(MULTIPLY);
          break;
        case DIVIDE:
          node = jj_consume_token(DIVIDE);
          break;
        case REMAINDER:
          node = jj_consume_token(REMAINDER);
          break;
        default:
          jj_la1[34] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        symbol=node.image;
        if(preStr!=null){
                pretem="T"+(ncount-1);
        }
        MiddleR = Factor();
        middletemp=MiddleR.getName();
        middle=MiddleR.getValue();
        count++;
            temp="T"+ncount;
            ncount++;
            if(preStr==null){

                        //æŠŠå¼€å§‹å?å’Œä¸­é—´å?æ”¾åœ¨ä¸´æ—¶å˜é‡é‡?
                        QTTable.addQTInfo(new QTInfo(count,symbol,rValue.getName(),middletemp,temp));
                }else{
                        //æŠŠå¼€å§‹å?å’Œä¸­é—´å?æ”¾åœ¨ä¸´æ—¶å˜é‡é‡?
                        QTTable.addQTInfo(new QTInfo(count,symbol,pretem,middletemp,temp));
                }
            result=Integer.parseInt(result)*Integer.parseInt(middle)+"";
            preStr=temp;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
        rValue=new Record(temp,result);
        {if (true) return rValue;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//ç±»å‹å®šä¹‰
  final public String Type() throws ParseException {
 /*@bgen(jjtree) Type */
SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token node;
String type;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FLOAT:
        node = jj_consume_token(FLOAT);
        break;
      case LONG:
        node = jj_consume_token(LONG);
        break;
      case INT:
        node = jj_consume_token(INT);
        break;
      case SHORT:
        node = jj_consume_token(SHORT);
        break;
      case CHAR:
        node = jj_consume_token(CHAR);
        break;
      case DOUBLE:
        node = jj_consume_token(DOUBLE);
        break;
      default:
        jj_la1[35] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          type=node.image;
          {if (true) return type;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public CompilerTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[36];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x201,0x1fa39000,0x1fa39000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x4000,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f800000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x80000600,0x80000600,0x800000,0x0,0x800,0x8000000,0x800000,0x0,0x800,0x8000000,0x8000000,0x82200000,0x82200000,0x8000000,0x800000,0x80200000,0x1f0,0xff0,0x18000000,0x80000600,0x0,0x0,0x0,0x3f000,0x40000,0x80000,0x600,0x88000000,0x88000000,0x3f000,0x30,0x30,0x1c0,0x1c0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x2,0x2,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public Compiler(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Compiler(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new CompilerTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 36; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 36; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Compiler(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new CompilerTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 36; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 36; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Compiler(CompilerTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 36; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(CompilerTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 36; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[67];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 36; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 67; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
